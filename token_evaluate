#!/bin/bash

# token_evaluate - CLI per stimare token output JSON da blocchi HTML
# Sintassi: token_evaluate [--verbose|-v] file_input "istruzioni"

# Gestione pulizia all'uscita
cleanup() {
    if [ -n "$spinner_pid" ]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null
    fi
    echo -e "\r\033[K" >&2  # Pulisce la riga
}
trap cleanup EXIT INT TERM

# Inizializza variabili
verbose=false
file_input=""
istruzioni_utente=""

# Parsing parametri
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            verbose=true
            shift
            ;;
        *)
            if [ -z "$file_input" ]; then
                file_input="$1"
            elif [ -z "$istruzioni_utente" ]; then
                istruzioni_utente="$1"
            else
                echo "Errore: Troppi parametri" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Verifica numero di parametri
if [ -z "$file_input" ] || [ -z "$istruzioni_utente" ]; then
    echo "Errore: Numero di parametri non corretto" >&2
    echo "Uso: token_evaluate [--verbose|-v] file_input \"istruzioni\"" >&2
    echo "     --verbose, -v : Mostra i JSON di output e i token count delle singole esecuzioni" >&2
    echo "Esempio: token_evaluate sample/input_01.html \"vorrei estrarre provincia, comune, centro, indirizzo, contatti e orari\"" >&2
    echo "         token_evaluate -v sample/input_01.html \"estrai tutti i campi\"" >&2
    exit 1
fi

# Modifica automaticamente le istruzioni per sempre estrarre un elemento random (non il primo)
istruzioni="$istruzioni_utente. Estrai sempre un elemento casuale."

# Verifica esistenza file input
if [ ! -f "$file_input" ]; then
    echo "Errore: File '$file_input' non trovato" >&2
    exit 1
fi

# Verifica disponibilità comandi necessari
for cmd in llm ttok cat; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Errore: Comando '$cmd' non trovato. Assicurati che sia installato e nel PATH" >&2
        exit 1
    fi
done

# Array per memorizzare i risultati delle 3 esecuzioni
declare -a results
declare -a json_outputs

if [ "$verbose" = false ]; then
    echo -n "Calcolo in corso" >&2
fi

# Esegue il comando 3 volte
for i in {1..3}; do
    if [ "$verbose" = false ]; then
        # Animazione con puntini durante l'esecuzione (solo in modalità non-verbose)
        (
            while true; do
                for dots in "." ".." "..."; do
                    echo -ne "\r\033[KCalcolo in corso$dots" >&2
                    sleep 0.5
                done
            done
        ) &
        spinner_pid=$!
    else
        echo "=== Esecuzione $i/3 ===" >&2
    fi

    # Cattura l'output JSON completo quando in modalità verbose
    if [ "$verbose" = true ]; then
        json_output=$(cat "$file_input" | llm -t token_output -p istruzioni "$istruzioni" 2>/dev/null)
        result=$(echo "$json_output" | ttok 2>/dev/null)

        # Salva il JSON per la visualizzazione
        json_outputs[$i]="$json_output"

        echo "JSON Output:" >&2
        echo "$json_output" >&2
        echo "Token count: $result" >&2
        echo "" >&2
    else
        # Modalità normale: solo token count
        result=$(cat "$file_input" | llm -t token_output -p istruzioni "$istruzioni" | ttok 2>/dev/null)

        # Ferma l'animazione in ogni caso
        if [ -n "$spinner_pid" ]; then
            kill $spinner_pid 2>/dev/null
            wait $spinner_pid 2>/dev/null
        fi
    fi

    # Verifica che il risultato sia un numero
    if ! [[ "$result" =~ ^[0-9]+$ ]]; then
        if [ "$verbose" = false ]; then
            echo -e "\r\033[K" >&2
        fi
        echo "Errore: Esecuzione $i ha prodotto un risultato non numerico: '$result'" >&2
        exit 1
    fi

    # Aggiunge il risultato all'array
    results[$i]=$result

    # Delay di 4 secondi tra le richieste per rispettare rate limit (max 15/min = 1 ogni 4 sec)
    if [ $i -lt 3 ]; then
        sleep 4
    fi
done

# Pulisce la riga dell'animazione (solo in modalità non-verbose)
if [ "$verbose" = false ]; then
    echo -e "\r\033[K" >&2
fi

# Calcola la media
total=0
for result in "${results[@]}"; do
    total=$((total + result))
done

# Calcola la media e arrotonda all'intero più vicino
# Usa bc per calcoli in virgola mobile se disponibile, altrimenti aritmetica bash
if command -v bc >/dev/null 2>&1; then
    average=$(echo "scale=0; ($total + 1.5) / 3" | bc)
else
    # Arrotondamento manuale: aggiunge 1 se il resto è >= 1.5
    remainder=$((total % 3))
    average=$((total / 3))
    if [ $remainder -ge 2 ]; then
        average=$((average + 1))
    fi
fi

# Mostra riepilogo in modalità verbose
if [ "$verbose" = true ]; then
    echo "=== RIEPILOGO ===" >&2
    echo "Token count delle 3 esecuzioni: ${results[1]}, ${results[2]}, ${results[3]}" >&2
    echo "Media calcolata: $average" >&2
    echo "" >&2
fi

# Output del risultato (solo il numero)
echo "$average"
