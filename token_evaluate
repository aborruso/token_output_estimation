#!/bin/bash

# token_evaluate - CLI to estimate token count for JSON output from structured text files
# Usage: token_evaluate [--verbose|-v] [--items|-n number] input_file "instructions"

# Cleanup handler for spinner and exit
cleanup() {
    if [ -n "$spinner_pid" ]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null
    fi
    echo -e "\r\033[K" >&2  # Clear the line
}
trap cleanup EXIT INT TERM

# Initialize variables
verbose=false
file_input=""
user_instructions=""
items_count=1

# Parse parameters
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            verbose=true
            shift
            ;;
        -n|--items)
            if [ -z "$2" ] || [[ "$2" =~ ^- ]]; then
                echo "Error: --items requires a number" >&2
                exit 1
            fi
            items_count="$2"
            shift 2
            ;;
        *)
            if [ -z "$file_input" ]; then
                file_input="$1"
            elif [ -z "$user_instructions" ]; then
                user_instructions="$1"
            else
                echo "Error: Too many parameters" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Check parameter count and handle pipe input
if [ -t 0 ]; then
    # No pipe input - require file and instructions
    if [ -z "$file_input" ] || [ -z "$user_instructions" ]; then
        echo "Error: Incorrect number of parameters" >&2
        echo "Usage: token_evaluate [--verbose|-v] [--items|-n number] input_file \"instructions\"" >&2
        echo "   Or: cat input_file | token_evaluate [--verbose|-v] \"instructions\"" >&2
        echo "       --verbose, -v : Show output JSON and token count for each run" >&2
        echo "Example: token_evaluate sample/input_01.html \"extract province, city, center, address, contacts and hours\"" >&2
        echo "         cat data.csv | token_evaluate \"extract name and email\"" >&2
        echo "         token_evaluate -v sample/input_01.html \"extract all fields\"" >&2
        exit 1
    fi
    input_data=""  # Will read from file each time
else
    # Pipe input - only need instructions
    if [ -z "$user_instructions" ]; then
        # If file_input is provided but user_instructions is empty,
        # treat file_input as instructions (shifted parameters)
        if [ -n "$file_input" ]; then
            user_instructions="$file_input"
            file_input=""
        else
            echo "Error: Instructions required when using pipe input" >&2
            echo "Usage: cat input_file | token_evaluate [--verbose|-v] [--items|-n number] \"instructions\"" >&2
            exit 1
        fi
    fi
    # Read all stdin data once and store it
    input_data=$(cat)
fi

# Always add random element extraction to instructions
instructions="$user_instructions. Always extract a random element, not the first one."

# Validate items_count is a positive integer
if ! [[ "$items_count" =~ ^[1-9][0-9]*$ ]]; then
    echo "Error: --items must be a positive integer" >&2
    exit 1
fi

# Check input file existence (only if using file input)
if [ -n "$file_input" ] && [ ! -f "$file_input" ]; then
    echo "Error: File '$file_input' not found" >&2
    exit 1
fi

# Check dependencies
for dep in llm ttok; do
    if ! command -v "$dep" >/dev/null 2>&1; then
        echo "Error: Missing dependency: '$dep' not found in PATH. Please install '$dep' before proceeding." >&2
        exit 1
    fi
done

# Check input size and truncate if necessary
max_tokens=500000

if [ -n "$input_data" ]; then
    # Pipe input - check token count
    input_token_count=$(echo "$input_data" | ttok 2>/dev/null)
    if [ "$input_token_count" -gt "$max_tokens" ]; then
        echo "Warning: Input contains $input_token_count tokens, truncating to $max_tokens tokens" >&2
        input_data=$(echo "$input_data" | ttok -t "$max_tokens" 2>/dev/null)
    fi
else
    # File input - check token count
    input_token_count=$(cat "$file_input" | ttok 2>/dev/null)
    if [ "$input_token_count" -gt "$max_tokens" ]; then
        echo "Warning: Input file contains $input_token_count tokens, truncating to $max_tokens tokens" >&2
        # For file input, we'll truncate on-the-fly during processing
        file_truncated=true
    else
        file_truncated=false
    fi
fi

# Array to store results of the 3 runs
declare -a results
declare -a json_outputs

# Start continuous spinner only in non-verbose mode
if [ "$verbose" = false ]; then
    echo -n "Processing" >&2
    (
        while true; do
            for dots in "." ".." "..."; do
                echo -ne "\r\033[KProcessing$dots" >&2
                sleep 0.5
            done
        done
    ) &
    spinner_pid=$!
fi

# Run the command 3 times
for i in {1..3}; do
    if [ "$verbose" = true ]; then
        echo "=== Run $i/3 ===" >&2
    fi

    # Retry loop for empty JSON responses
    retry_count=0
    max_retries=3

    while [ $retry_count -lt $max_retries ]; do
        # Capture full JSON output in verbose mode
        if [ "$verbose" = true ]; then
            if [ -n "$input_data" ]; then
                # Using pipe data (already truncated if needed)
                json_output=$(echo "$input_data" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
            else
                # Using file data - truncate if needed
                if [ "$file_truncated" = true ]; then
                    json_output=$(cat "$file_input" | ttok -t "$max_tokens" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
                else
                    json_output=$(cat "$file_input" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
                fi
            fi
            result=$(echo "$json_output" | ttok 2>/dev/null)
        else
            # Normal mode: only token count
            if [ -n "$input_data" ]; then
                # Using pipe data (already truncated if needed)
                json_output=$(echo "$input_data" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
            else
                # Using file data - truncate if needed
                if [ "$file_truncated" = true ]; then
                    json_output=$(cat "$file_input" | ttok -t "$max_tokens" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
                else
                    json_output=$(cat "$file_input" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
                fi
            fi
            result=$(echo "$json_output" | ttok 2>/dev/null)
        fi

        # Check if JSON is effectively empty (only {} or contains only empty values)
        if [[ "$json_output" =~ ^\{\}$ ]] || [[ "$json_output" =~ ^\{[[:space:]]*\}$ ]]; then
            retry_count=$((retry_count + 1))
            if [ "$verbose" = true ]; then
                echo "Empty JSON detected, retrying... (attempt $retry_count/$max_retries)" >&2
            fi
            if [ $retry_count -lt $max_retries ]; then
                sleep 2  # Short delay before retry
            fi
        else
            # Valid JSON found, break retry loop
            break
        fi
    done

    # If all retries failed, show error
    if [ $retry_count -eq $max_retries ] && ([[ "$json_output" =~ ^\{\}$ ]] || [[ "$json_output" =~ ^\{[[:space:]]*\}$ ]]); then
        if [ "$verbose" = false ]; then
            # Stop spinner before showing error
            if [ -n "$spinner_pid" ]; then
                kill $spinner_pid 2>/dev/null
                wait $spinner_pid 2>/dev/null
            fi
            echo -e "\r\033[K" >&2
        fi
        echo "Error: Run $i failed to extract valid data after $max_retries attempts" >&2
        exit 1
    fi

    if [ "$verbose" = true ]; then
        # Save JSON for display
        json_outputs[$i]="$json_output"

        echo "JSON Output:" >&2
        echo "$json_output" >&2
        echo "Token count: $result" >&2
        echo "" >&2
    fi

    # Check that result is a number
    if ! [[ "$result" =~ ^[0-9]+$ ]]; then
        if [ "$verbose" = false ]; then
            # Stop spinner before showing error
            if [ -n "$spinner_pid" ]; then
                kill $spinner_pid 2>/dev/null
                wait $spinner_pid 2>/dev/null
            fi
            echo -e "\r\033[K" >&2
        fi
        echo "Error: Run $i produced a non-numeric result: '$result'" >&2
        exit 1
    fi

    # Add result to array
    results[$i]=$result

    # 4 second delay for rate limiting (max 15/min = 1 every 4 sec)
    if [ $i -lt 3 ]; then
        sleep 4
    fi
done

# Stop spinner and clear animation line (only in non-verbose mode)
if [ "$verbose" = false ]; then
    if [ -n "$spinner_pid" ]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null
    fi
    echo -e "\r\033[K" >&2
fi

# Calculate the total
total=0
for result in "${results[@]}"; do
    total=$((total + result))
done

# Calculate the mean and round to nearest integer
# Use bc for floating point if available, otherwise bash arithmetic
if command -v bc >/dev/null 2>&1; then
    average=$(echo "scale=0; ($total + 1.5) / 3" | bc)
else
    # Manual rounding: add 1 if remainder >= 1.5
    remainder=$((total % 3))
    average=$((total / 3))
    if [ $remainder -ge 2 ]; then
        average=$((average + 1))
    fi
fi

# Show summary in verbose mode
if [ "$verbose" = true ]; then
    echo "=== SUMMARY ===" >&2
    echo "Token count for 3 runs: ${results[1]}, ${results[2]}, ${results[3]}" >&2
    echo "Calculated mean: $average" >&2
    if [ "$items_count" -gt 1 ]; then
        echo "Items count: $items_count" >&2
        echo "Total estimated tokens: $((average * items_count))" >&2
    fi
    echo "" >&2
fi

# Generate JSON output
if [ "$items_count" -eq 1 ]; then
    # Simple case: only single_item_tokens
    json_output="{\"single_item_tokens\": $average}"
else
    # Calculate total estimated tokens
    if command -v bc >/dev/null 2>&1; then
        total_estimated=$(echo "$average * $items_count" | bc)
    else
        total_estimated=$((average * items_count))
    fi
    # Full case: include items and total_estimated_tokens
    json_output="{\"single_item_tokens\": $average, \"items\": $items_count, \"total_estimated_tokens\": $total_estimated}"
fi

# Output JSON Line
echo "$json_output"
