#!/bin/bash

# token_evaluate - CLI to estimate token count for JSON output from structured text files
# Usage: token_evaluate [--verbose|-v] input_file "instructions"

# Cleanup handler for spinner and exit
cleanup() {
    if [ -n "$spinner_pid" ]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null
    fi
    echo -e "\r\033[K" >&2  # Clear the line
}
trap cleanup EXIT INT TERM

# Initialize variables
verbose=false
file_input=""
user_instructions=""

# Parse parameters
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            verbose=true
            shift
            ;;
        *)
            if [ -z "$file_input" ]; then
                file_input="$1"
            elif [ -z "$user_instructions" ]; then
                user_instructions="$1"
            else
                echo "Error: Too many parameters" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Check parameter count
if [ -z "$file_input" ] || [ -z "$user_instructions" ]; then
    echo "Error: Incorrect number of parameters" >&2
    echo "Usage: token_evaluate [--verbose|-v] input_file \"instructions\"" >&2
    echo "       --verbose, -v : Show output JSON and token count for each run" >&2
    echo "Example: token_evaluate sample/input_01.html \"extract province, city, center, address, contacts and hours\"" >&2
    echo "         token_evaluate -v sample/input_01.html \"extract all fields\"" >&2
    exit 1
fi

# Always add random element extraction to instructions
instructions="$user_instructions. Always extract a random element, not the first one."

# Check input file existence
if [ ! -f "$file_input" ]; then
    echo "Error: File '$file_input' not found" >&2
    exit 1
fi

# Check dependencies
for dep in llm ttok; do
    if ! command -v "$dep" >/dev/null 2>&1; then
        echo "Error: Missing dependency: '$dep' not found in PATH. Please install '$dep' before proceeding." >&2
        exit 1
    fi
done

# Array to store results of the 3 runs
declare -a results
declare -a json_outputs

# Start continuous spinner only in non-verbose mode
if [ "$verbose" = false ]; then
    echo -n "Processing" >&2
    (
        while true; do
            for dots in "." ".." "..."; do
                echo -ne "\r\033[KProcessing$dots" >&2
                sleep 0.5
            done
        done
    ) &
    spinner_pid=$!
fi

# Run the command 3 times
for i in {1..3}; do
    if [ "$verbose" = true ]; then
        echo "=== Run $i/3 ===" >&2
    fi

    # Capture full JSON output in verbose mode
    if [ "$verbose" = true ]; then
        json_output=$(cat "$file_input" | llm -t token_output -p instructions "$instructions" 2>/dev/null)
        result=$(echo "$json_output" | ttok 2>/dev/null)

        # Save JSON for display
        json_outputs[$i]="$json_output"

        echo "JSON Output:" >&2
        echo "$json_output" >&2
        echo "Token count: $result" >&2
        echo "" >&2
    else
        # Normal mode: only token count
        result=$(cat "$file_input" | llm -t token_output -p instructions "$instructions" | ttok 2>/dev/null)
    fi

    # Check that result is a number
    if ! [[ "$result" =~ ^[0-9]+$ ]]; then
        if [ "$verbose" = false ]; then
            # Stop spinner before showing error
            if [ -n "$spinner_pid" ]; then
                kill $spinner_pid 2>/dev/null
                wait $spinner_pid 2>/dev/null
            fi
            echo -e "\r\033[K" >&2
        fi
        echo "Error: Run $i produced a non-numeric result: '$result'" >&2
        exit 1
    fi

    # Add result to array
    results[$i]=$result

    # 4 second delay for rate limiting (max 15/min = 1 every 4 sec)
    if [ $i -lt 3 ]; then
        sleep 4
    fi
done

# Stop spinner and clear animation line (only in non-verbose mode)
if [ "$verbose" = false ]; then
    if [ -n "$spinner_pid" ]; then
        kill $spinner_pid 2>/dev/null
        wait $spinner_pid 2>/dev/null
    fi
    echo -e "\r\033[K" >&2
fi

# Calculate the total
total=0
for result in "${results[@]}"; do
    total=$((total + result))
done

# Calculate the mean and round to nearest integer
# Use bc for floating point if available, otherwise bash arithmetic
if command -v bc >/dev/null 2>&1; then
    average=$(echo "scale=0; ($total + 1.5) / 3" | bc)
else
    # Manual rounding: add 1 if remainder >= 1.5
    remainder=$((total % 3))
    average=$((total / 3))
    if [ $remainder -ge 2 ]; then
        average=$((average + 1))
    fi
fi

# Show summary in verbose mode
if [ "$verbose" = true ]; then
    echo "=== SUMMARY ===" >&2
    echo "Token count for 3 runs: ${results[1]}, ${results[2]}, ${results[3]}" >&2
    echo "Calculated mean: $average" >&2
    echo "" >&2
fi

# Output only the final number
echo "$average"
